Проблематика многопоточности: -
1. Видимость памяти - память у каждого потока своя, а данные хранятся в общей. Иногда один поток изменяет данные у себя,
а запушить в главную память не успевает. Другой поток в это время читает из главной памяти и записывает себе в кэш,
а там другое значение переменной
2. Контроль исполнения - !!!!

Специфические грабли многопоточности, связанные с проблематикой:
1. Atomicity - атомарность операций. Некоторые операции, которые должны быть атомарными, на самом деле могут таковыми не
являться (запись - чтение из 64 битных типов данных). Также иногда нужно сделать атомарной кастомную операцию. Например,
дебит-кредит должны либо полностью списываться/начисляться, либо не начисляться вообще. В Java решается Atomic - классами,
созданием объекта с синхронизацией, содержащего нужные переменные или volatile - переменными. Лучше Atomic делать. Atomic
работают так - если один из потоков делает одну из операций, входящую в атомарный блок операций, то другой поток ждет выполнения
всего оставшегося блока первым.

2. Visibility - Видимость данных (1 проблема). Важно лишь то, при каких условиях один поток видит изменения,
выполненные другим потоком. Здесь есть много типовых названий проблемных ситуаций - out-of-thin-air,
happens-before и т.д. Опишем
2.1 Out-of-air - не существует в Java (значения не могут из воздуха браться, в С++ могут)
2.2 Happens-before - Отношение между операциями, когда одна операция гарантированно будет исполнена после другой.
Достигается volatile (чтение всегда после записи), но каким чертом, если нет блокировки???
Интересный комментарий -
happens-before has a very specific meaning in the JMM.
In particular, it does not mean that y=6 must be subsequent to x=5 in T1
from a wall clock perspective.
It only means that the sequence of actions executed by T1 must be consistent with that order.
2.3 Double-checking locking - перед тем, как взять монитор объекта сначала проверяем его на критерии (например,
если нулл, то берем монитор и инициализируем его). Плохо, потому что есть вероятность в одном из потоков получить
ссылку на недоинициализированный другим потоком объект.
2.4 Check-than-act - сначала проверили протухшие данные, а потом начали действия с уже новыми
(а дейстия определялись старыми) ЧАСТО СВЯЗАНО С RACE - CONDITIONS (в итоге cta получаем его). CTA часто используется в --
lazy init-ах (вот тут то и нужен volatile).
2.5 Read-modify-write - ситуация, когда мы хотим изменить данные в переменной (++ и -- входят).
Сначала читаем ее, потом изменяем, а потом записываем в память. Может привести к race-condition
RMW & CTA MUST ALWAYS BE ATOMIC!

3. Reordering - действия, выполненные одним потоком, другой поток увидит в другом порядке.

4. Publishing - сделать код доступным для кода вне текущего скопа (хранить ссылку где-то, где ее может подцепить другой
код, возвращать ссылку из неприватного метода, передвать параметром в сторонний метод). Не нужно публиковать внутренние
переменные классов, которые отвечают за его инвариантность, не нужно публковать не полностью инициализированные объекты.

5. Escaping - публикация чего-то, что не подразумевает публикацию (неготовые обьекты, внутренние переменные и т.д.)



Критические ситуации многопоточности:
1. Deadlock -
1.1 Взаимная блокировка -
2. Race conditions - когда правильный результат зависит от времени обращения разных потоков
(в итоге потоки могут принимать неправильные решения, основываясь на протухших данных
3. Data conditions - когда не используется синхронизация для координации доступа к общей не файнал переменной




synchronized - блочим код под локом этого объекта (никто не может его использовать). Когда мы залезаем в монитор объекта,
мы скидываем кэш потока (ядра, на котором он выполняется) и берем актуальные данные из главной памяти. Делаем свою логику
(в это время никто не может работать с заблоченными данными) и когда отпускаем монитор объекта записываем в основную память
результаты своей логики.

volatile - каждый раз берем только актуальные данные из переменной (лезем в память, а не из кэша)
Действует и на поля volatile обьектов. Но не альтернатива synchronized! Также обеспечивает атомарность записи
в переменные 64битных типов данных. Кроме того, обеспечивает порядок действий над переменной -
если один поток записывает в переменную, то друой подождет, пока тот запишет и только тогда прочитает.
НО два потока могут писать в переменную одновременно, что плохо.



Есть такие прелести concurrency:
Владелец переменных, владелец состояния (тупа обьект, о котором мы говорим, и состояние которого зависит от некоторого
количества переменных